Pre-Prova

============================Questao 1 ==========================================
(4 (2 (1)(3)) (10 (7(5)(8)) (12(11)(15(14)))) )
Não está balanceada, pois previamente a diferença da altura da sub-arvore da
esquerda e da direita era de 1, e adicionando 14 viraria 2, pois o 14 seria um
nó filho do nó 15, que faria a sub-arvore da direita ter altura de 4. Com isso 
a sub-arvore da esquerda permaneceria com 2 de altura. 

============================Questao 2 ==================================

O motivo de utilizar a complexidade do caso médio para comparar o Quicksort com 
outros métodos de ordenação se deve ao fato de que a complexidade média fornece 
uma visão mais realista do desempenho do algoritmo em situações típicas.

============================Questao 3 e 4 =======================================

#include <stdio.h>
#include <stdlib.h>

typedef struct reg_no {
    float info;
    struct reg_no *prox;
} no;

no *cria_no(float valor) {
    no *novo_no = (no *) malloc(sizeof(no));
    novo_no->info = valor;
    novo_no->prox = NULL;
    return novo_no;
}

void imprime_nos(no *lista) {
    no *no_atual = lista;
    while (no_atual != NULL) {
        printf("%.2f ", no_atual->info);
        no_atual = no_atual->prox;
    }
}

no *insere_no_fim(no *lista, float valor) {
    no *novo_no = cria_no(valor);
    if (lista == NULL) {
        lista = novo_no;
    } else {
        no *no_atual = lista;
        while (no_atual->prox != NULL) {
            no_atual = no_atual->prox;
        }
        no_atual->prox = novo_no;
    }
    return lista;
}

no *maior_valor (no* lista){
    no *no_atual = lista;
    no *maior_no = lista;
    while (no_atual != NULL) {
        if (no_atual->info > maior_no->info) {
            maior_no = no_atual;
        }
        no_atual = no_atual->prox;
    }

    return maior_no;
}

no *menor_valor(no *lista) {
    if (lista == NULL) {
        printf("Lista vazia.\n");
        return NULL;
    }

    no *no_atual = lista;
    no *menor_no = lista;

    while (no_atual != NULL) {
        if (no_atual->info < menor_no->info) {
            menor_no = no_atual;
        }
        no_atual = no_atual->prox;
    }

    return menor_no;
}

void inverte_maior_menor(no *lista) {
    
    no *no_maior = maior_valor(lista);
    no *no_menor = menor_valor(lista);

    // Troca dos valores entre o maior e o menor
    float temp = no_maior->info;
    no_maior->info = no_menor->info;
    no_menor->info = temp;
}

void troca_primeiro_ultimo(no *lista) {
    no *no_atual = lista;
    while (no_atual->prox != NULL) {
        no_atual = no_atual->prox;
    }

    float temp = lista->info;
    lista->info = no_atual->info;
    no_atual->info = temp;
}

int main() {
    no *lista = NULL;

    lista = insere_no_fim(lista, 4.0);
    lista = insere_no_fim(lista, 6.0);
    lista = insere_no_fim(lista, 3.0);
    lista = insere_no_fim(lista, 1.0);
    lista = insere_no_fim(lista, 9.0);
    lista = insere_no_fim(lista, 5.0);

    imprime_nos(lista);
    printf("\n");

    no *no_maior = maior_valor(lista);
    printf("Maior valor: %.2f\n", no_maior->info);

    no *no_menor = menor_valor(lista);
    printf("Menor valor: %.2f\n", no_menor->info);

    inverte_maior_menor(lista);
    printf("Lista apos a inversao: ");
    imprime_nos(lista);
    printf("\n");

    troca_primeiro_ultimo(lista);
    printf("Lista apos a troca do primeiro com o ultimo valor: ");
    imprime_nos(lista);

    return 0;
}

=======================Ultima Questão====================================

#include <stdio.h>

typedef struct {
    int agencia;
    int conta;
    int tipo;
    float valor;
} Correntista;

float calcular_soma_tipo1(Correntista correntistas[], int n) {
    float soma = 0;
    int i;
    for (i = 0; i < n; i++) {
        if (correntistas[i].tipo == 1) {
            soma += correntistas[i].valor;
        }
    }
    return soma;
}

float calcular_soma_tipo2(Correntista correntistas[], int n) {
    float soma = 0;
    int i;
    for (i = 0; i < n; i++) {
        if (correntistas[i].tipo == 2) {
            soma += correntistas[i].valor;
        }
    }
    return soma;
}

int main() {
    Correntista correntistas[20]; // Capacidade máxima de 20 correntistas
    int num_correntistas = 10; // Número de correntistas a serem cadastrados

    // Cadastro dos correntistas
    int i;
    for (i = 0; i < num_correntistas; i++) {
        printf("Correntista %d:\n", i + 1);
        printf("Agencia: ");
        scanf("%d", &correntistas[i].agencia);
        printf("Conta: ");
        scanf("%d", &correntistas[i].conta);
        printf("Tipo de Conta (1 ou 2): ");
        scanf("%d", &correntistas[i].tipo);
        printf("Valor em Conta: ");
        scanf("%f", &correntistas[i].valor);
        printf("\n");
    }

    // Cálculo da soma dos valores em contas do tipo 1
    float soma_tipo1 = calcular_soma_tipo1(correntistas, num_correntistas);

    // Cálculo da soma dos valores em contas do tipo 2
    float soma_tipo2 = calcular_soma_tipo2(correntistas, num_correntistas);

    // Impressão dos resultados
    printf("Soma dos valores em contas do tipo 1: %.2f\n", soma_tipo1);
    printf("Soma dos valores em contas do tipo 2: %.2f\n", soma_tipo2);

    return 0;
}

==========================================================================